SHEBANG
#!/usr/bin/python ou
#!/usr/bin/env python3 
Informa o terminal que aquele programa roda com o Python3 da 
env em execução, esta forma é possivel omitir o interpretador e executar o
 script diretamente pelo seu nome.

COMENTÁRIO MULTI LINHAS
É uma boa prática adicionar o comentário nas primeiras linhas explicando o
objetivo do script e provendo documentação para o usuário.

    Exemplo de comentário multi linha:
    """Hello World Multi Linguas.

    Dependendo da lingua configura no ambiente o programa exibe a mensagem
    correspondente.

    Como usar:

    Tenha a variavel LANG devidamente configurada ex:

        export LANG=pt_BR

    Execução:
        python hello.py
        ou
        ./hello.py
    """

DUNDER
São variáveis de metadados que iniciam e terminam com dois _
    Exemplo:
    __version__ = "0.0.1"
    __author__ = "Dalton Augusto Soares"
    __license__ = "Unlicense"

IMPORT MÓDULO
Usei o import do módulo os o que permite interagir com o sistema operacional.
    Exemplo:
    current_language = os.getenv("LANG", "en_US")
    os.getenv("LANG", "en_US") busca pela variável de ambiente LANG, caso não
    encontre usa en_US como padrão.
    Tem o mesmo resultado da execução de env | grep LANG no terminal linux.
    No windows não consegui recuperar o LANG com o módulo os, utilizei o locate

FATIAMENTO DE TEXTO
Utilizado o [:5] para recuperar os 5 primeiros caractéres do texto.
    Exemplo:
    current_language = os.getenv("LANG", "en_US")[:5]

CONDICIONAL IF E ELIF
if é usado para definir um teste e usado com uma expressão de comparação
como por exemplo 1 > 2 e neste caso teriamos a condicional:
se 1 for maior que 2 (execute determinada instrução) traduzindo isso para código seria:
if 1 > 2:
    # faça algo aqui
        
    Exemplo:
    if current_language == "pt_BR":
        msg = "Olá, Mundo!"
    elif current_language == "it_IT":
        msg = "Ciao, Mondo!"
    elif current_language == "fr_FR":
        msg = "Bonjour, Monde!"

EXPRESSÃO / EXPRESSION
Instrução é um código que você escreve e que espera um valor de retorno.
    Exemplo:
    1 + 1 = 2
    8 > 10 = Falso
    8 < 10 = Verdadeiro    

DECLARAÇÃO / STATEMENT 
Instrução que prepara o interpretador para uma determinada tarefa, mas não 
retorna valor.
    Exemplo: if, else, def, for, while, pass
Observação: Geralmente um statement vem acompanhado de uma expressão.
O if logo depois tem uma expressão de comparação normalmente.

ATRIBUIÇÃO / ASSIGNMENT
 Instrução que pega o retorno de uma expressão e processa o seu valor com o 
 intuito de armazenar.
    Exemplo: 
    soma = 40 + 2
    soma += 3
    soma -= 3

INDENTATION / IDENTAÇÃO / RECUO
Em python um bloco de código inicia sempre que existe a presença de : no fim de
uma linha. A linha que vem logo após o início do bloco obrigatoriamente tem que
ter um recúo, o que chamamos de identação. Nas convenções do python não se usa 
o tab para o recúo, é utilizado 4 espaços. Hoje a maioria dos editores já vem 
configurado para o tab representar 4 espaços.

VIRTUAL ENVIRONMENT / AMBIENTE VIRTUAL
Com o virtual env temos um python separado sem afetar ou ser
afetado pelo python utilizado pelo S.O. Além disso também podemos instalar
bibliotecas prontas e instalar ferramentas sem o risco de conflitos.
    

    Exemplo Linux:
    1 - Criando o ambiente virtual e 2 - ativando o ambiente virtual.
    1) python3 -m venv .venv
    2) source .venv/bin/activate
Obs: Se for o caso, aprender como ativar o venv no Windows. 
Dentro do mesmo caminho tem o arquivo Activate.ps1

Para saber qual é a virtual env executar which python ou
python -m site
(.venv) daltonlab@DaltonSoares:~/python-base$ python -m site
sys.path = [
  -> -> '/home/daltonlab/python-base', <- <-
    '/usr/lib/python312.zip',
    '/usr/lib/python3.12',
    '/usr/lib/python3.12/lib-dynload',
  -> -> '/home/daltonlab/python-base/.venv/lib/python3.12/site-packages', <- <-
]

PIP
Pip é o gerenciador de pacotes do python. Os pacotes são baixados do repositório
https://pypi.org que tem diversos projetos para serem utilizados.

Antes de utilizar o pip é sempre bom fazer o upgrade do próprio pip.
    python -m pip install --upgrade pip

Para instalar uma biblioteca com o pip é como abaixo.
    Exemplo:
    python -m pip install ipython
O ipython é um terminal python muito mais completo, ele é o Jupiter Notebook
só que no terminal.

SCALAR TYPES - TIPOS PRIMÁRIOS
Serve para representar um único valor, ex: numero = 65.
No python não é necessário fazer a atribuição do tipo de dado na declaração. 
O python faz a atribuição dinâmica. Se quiser podemos utilizar mas é redundante
numero = 65 ou numero = int(65), porém o python já reconhecendo o tipo.

dir(int) digitado no terminal mostra com resultado toda a implementação.
Os que não começam com _ são métodos públicos e podem ser chamados diretamente.

FLOAT é um tipo de dados que guarda valores quebrados, como 5.5, -15,2, etc
Para fins de aprendizado posso utilizar o float para representar dinheiro,
porém na vida real tem outros tipos de dados como decimal e currency.

BOOL - o Tipo boleano só tem dois valores, true ou falso.
E ele serve para criar flags.
False = 0 e True = 1.
O if por exemplo usa muito o tipo de dado bool fazendo suas comparacoes 
pois o resultado sempre será boleano.

NoneType - é o tipo significa nulo, ausencia de valor.
No python não é possível criar uma variável e não atribuir valor,
como é feito em outras linguagens. 
    Exemplo: 
    In [27]: nome=None
    In [28]: type(nome)
    Out[28]: NoneType

RANGE / LIST
Para criar uma lista de com valores manualmente seria:
    base = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Para preencher essa lista automaticamente existe o range.
Particularidade é que o último número passado ao range tem que ser n+1 do que
você quer na lista. Uma lista de 1 a 10 preenche (1,11)
    base = range(1, 11) 

Para converter o range em uma lista.
    base = list(range(1,11))

Lista são objetos Iterable (percorríveis), para percorrer a lista o for é usado

STRING - Cadeia de caractéres
ASCII TABLE - O sistema operacional tem essa tabela gravada. Ela só tem 127 
posições, representando 127 caracteres e alguns tipos especiais.
UNICODE é uma tabela universal onde vai ter todos os caracteres, 120 mil.
e resolve a limitação do ASCII que só tinha caracteres do idioma inglês.
Hoje a maioria das lingaguens de programação utilizam a tabela UTF-8
que é UNICODE que tem 8 bits em cada posição.

    Exemplos de alguns métodos que podem ser usados com strings:
    In [7]: nome="dalton soares"

    In [8]: nome.upper()
    Out[8]: 'DALTON SOARES'

    In [9]: nome.lower()
    Out[9]: 'dalton soares'

    In [10]: nome.capitalize()
    Out[10]: 'Dalton soares'

    In [11]: nome.title()
    Out[11]: 'Dalton Soares'

    In [12]: nome.split()
    Out[12]: ['dalton', 'soares']

    In [13]: nome.startswith("d")
    Out[13]: True

    In [14]: nome.endswith("a")
    Out[14]: False

    In [15]: nome.count("a")
    Out[15]: 2

    In [16]: nome.index("a")
    Out[16]: 1

    In [17]: nome.index("s")
    Out[17]: 7

    In [18]: nome[5]
    Out[18]: 'n'

    In [19]: len(nome)
    Out[19]: 13

    In [21]: sorted(nome)
    Out[21]: [' ', 'a', 'a', 'd', 'e', 'l', 'n', 'o', 'o', 'r', 's', 's', 't']

    In [23]: list(reversed(nome))
    Out[23]: ['s', 'e', 'r', 'a', 'o', 's', ' ', 'n', 'o', 't', 'l', 'a', 'd']

SERIALIZAÇÃO
---
---
---

SLICIABLE (string slicing) Fatiamento de String -
Utiliza o dunder método __getitem__
As strings podem ser fatiadas, ou seja, pegarmos item por item dela.
Exemplo:
    In [13]: list(nome)
    Out[13]: ['B', 'r', 'u', 'n', 'o']
               0,   1,   2,   3,   4

    índice 0
    In [14]: nome[0]
    Out[14]: 'B'

    índice 1
    In [15]: nome[1]
    Out[15]: 'r'

    Último índice (última posição) através do -1
    In [16]: nome[-1]
    Out[16]: 'o'

    A partir do índice 2 até o final
    In [17]: nome[2:]
    Out[17]: 'uno'

    A partir do índice 1 até até o índice 3 (o índice 4 não é incluído)
    In [18]: nome[1:4]
    Out[18]: 'run'

    Últimos 3 caractéres
    In [21]: nome[-3:]
    Out[21]: 'uno'

    In [31]: len(nome)
    Out[31]: 5    

O conceito é o mesmo para listas:
    Exemplo: 
    Definindo a lista
    In [22]: nomes = ["Bruno", "Ana", "Carlos", "Duda", "Eva"]

    In [23]: nomes[0]
    Out[23]: 'Bruno'

    In [24]: nomes[-1]
    Out[24]: 'Eva'

    In [25]: nomes[2:]
    Out[25]: ['Carlos', 'Duda', 'Eva']

    In [26]: nomes[1:4]
    Out[26]: ['Ana', 'Carlos', 'Duda']



CONCATENAÇÃO 

    In [32]: nome
    Out[32]: 'Maria'

    In [33]: saldo
    Out[33]: 30.0

    Dessa forma o texto e as variáveis são concatenados através do "+".
    Como a variável saldo é do tipo float, foi necessário converte-lá para str
    In [34]: "O saldo do " + nome + " é total de " + str(saldo)
    Out[34]: 'O saldo do Maria é total de 30.0'

CONCATENAÇÃO %s
É utilizado para logging pois a biblioteca de logs é muito antiga e ela não 
atualizou para o str.format p/ não quebrar programas que já usam dessa maneira.


STR.FORMAT {}
É muito utilizado para mensagens longas, e-mail
New style
srt.format()
msg = "Olá, {} você é o player n {} e você tem {} pontos"

msg.format("Bruno", 2, 987.2)
'Olá, Bruno você é o player n 2 e você tem 987.2 pontos'

NOMEPANDO O PLACEHOLDER
Para não correr o risco de haver confusão na ordem dos parâmetros é possível
nomear os parâmetros e ao formatar informar o nome do parâmetro e  o valor.
    msg = "Olá, {nome} você é o player n {num} e você tem {pontos} pontos"

Utilizando as duas maneiras abaixo o output será o mesmo pois foi utilizado
o placeholder nomeado.
    msg.format(nome="dalton", num=2, pontos=85.3)
    msg.format(num=2, pontos=85.3, nome="dalton")
        Out: 'Olá, dalton você é o player n 2 e você tem 85.3 pontos'

Formatando os espaços que receberão os dados.
    In [24]: msg = "Olá, {} você é o player n {:03d} e você tem {:.2f} pontos"

    In [25]: msg.format("Dalton", 2, 85.5)
    Out[25]: 'Olá, Dalton você é o player n 002 e você tem 85.50 pontos'

    {:03d} - O campo vai receber um digito inteiro e terá 3 casas.
    você é o player n 002

    {:.2f} - O campo vai receber um float e terá 2 casas depois da vírgula
    você tem 85.50 pontos

Pode-se também nomear E formatar o placeholder.
    In [115]: msg = "Você tem {pontos:.03f}"

    In [116]: msg.format(pontos=85.2)
    Out[116]: 'Você tem 85.200'    

Format para CENTRALIZAR
#A str passada será centralizada em 11 caracteres.
    In [7]: msg = "Olá, {:^11}"

    In [8]: msg.format("Dalton")
    Out[8]: 'Olá,   Dalton   ' 

    Alinhando à esquerda
    In [48]: "{:<20}".format("Dalton")
    Out[48]: 'Dalton              '

    Alinhando à direita
    In [49]: "{:>20}".format("Dalton")
    Out[49]: '              Dalton'

Preenchendo valores nos espaços em branco do alinhamento:
    In [61]: "{:_^20}".format("Dalton")
    Out[61]: '_______Dalton_______'

    In [62]: "{:_>20}".format("Dalton")
    Out[62]: '______________Dalton'

    In [63]: "{:_<20}".format("Dalton")
    Out[63]: 'Dalton______________'
    Obs: Isso pode ser utilizado para gerar títulos no terminal.


F-STRINGS - format strings
Utilizado em mensagens, print, error, etc.
f-string é bem similar com as outras formas de formatação porém sempre precisa
ter um nome no placeholder e esses nomes já precisam estar definidos.

    In [122]: nome = "Joao"

    In [123]: saldo = 89

    In [124]: f"Olá {nome} você tem {saldo}"
    Out[124]: 'Olá Joao você tem 89'

    Da mesma maneira também é possível formatar, veja o saldo.
    In [125]: f"Olá {nome} você tem {saldo:.2f}"
    Out[125]: 'Olá Joao você tem 89.00'


Em https://pyformat.info tem mais informações ou help('FORMATTING')

TIPOS COMPOSTOS

# Tuple ou Tupla em português
dados = "Bruno", 15, True, None, 45.3
A tupla é imutável, não é possível alterar os objetos da tupla.
Assim como na string pode-se acessar seus elementos usando []
dados[0] traz a string Bruno
dados[1] traz o número 15

Desempacotamento
dados = "Bruno", 15, True, None, 45.3
nome, numero, verifica, define, pontos = dados
Assim, cada variável automaticamente recebe o valor contido na tupla.

info = "bruno", "dalton", "soares", "thiago"
a, *nome, c = info
Da mesma maneira que acima, automaticamente os valores foram atribuídos
as variáveis porem com a diferença de que *nome recebeu os valores
"dalton", "soares" 
In [33]: nome
Out[33]: ['dalton', 'soares']

LISTA
A lista pode ser criada vazia.
    users = []
Método append adiciona itens na última posição da lista.
    In [36]: users.append("João")

    In [37]: users.append("Bruno")

    In [38]: users.append("Alice")

    In [39]: users
    Out[39]: ['João', 'Bruno', 'Alice']

Utilizando o insert eu posso escolher a posição que vou adicionar na lista
    In [40]: users.insert(0, "Miguel")

    In [41]: users
    Out[41]: ['Miguel', 'João', 'Bruno', 'Alice']

Revemo para remover alguém da lista. 
    In [43]: users.remove("Alice")

    In [44]: users
    Out[44]: ['Miguel', 'João', 'Bruno']

É possível fazer a junção de duas listas.
    In [52]: users
    Out[52]: ['Miguel', 'João', 'Bruno']

    In [53]: outra_lista
    Out[53]: ['Yumi', 'Dalton']

    In [54]: users + outra_lista
    Out[54]: ['Miguel', 'João', 'Bruno', 'Yumi', 'Dalton']    
As duas listas users e outra_lista continuam intactas e inalteradas.

In [59]: head, *body, tail = lista_completa

    In [60]: head
    Out[60]: 'Miguel'

    In [61]: body
    Out[61]: ['João', 'Bruno', 'Yumi']

    In [62]: tail
    Out[62]: 'Dalton'

Com o método extend é o join de uma lista na outra.
    In [65]: users
    Out[65]: ['Miguel', 'João', 'Bruno']

    In [66]: outra_lista
    Out[66]: ['Yumi', 'Dalton']

    In [67]:

    In [67]: users.extend(outra_lista)

    In [68]: users
    Out[68]: ['Miguel', 'João', 'Bruno', 'Yumi', 'Dalton']
    Da mesma maneira que o extend daria para utilizar o += 
    users += outra_lista

O método POP remove o último elemento da lista

    In [69]: users
    Out[69]: ['Miguel', 'João', 'Bruno', 'Yumi', 'Dalton']

    In [71]: users.pop()
    Out[71]: 'Dalton'

    In [72]: users.pop()
    Out[72]: 'Yumi'

    In [73]: users.pop()
    Out[73]: 'Bruno'

    In [74]: users
    Out[74]: ['Miguel', 'João']

SET / CONJUNTO 
set é um conjunto de itens únicos, ou seja, não duplicados.
Criando um set porém não é a melhor pois pode ser confundida com dicionário.
c1 = {1, 2, 3} 

O jeito preferido é usar a própria classe set.
Dentro do set pode-se passar um objetivo iterável.
c1 = set()
c1 = set((1, 2, 3))

Se achar que está estranho com os parenteses duplos dá para criar via lista.
c1 = set([1, 2, 3])

UNIÃO DE CONJUNTOS
    Lembrando que o set não tem itens repetidos.
    In [15]: set(conjunto_a) | set(conjunto_b)
    Out[15]: {1, 2, 3, 4, 5, 6, 7, 8}

    Outra maneira de fazer a mesma coisa é utilizando o método union
    set(conjunto_a).union(set(conjunto_b))

A melhor é já criando os conjuntos como SETs.
    In [17]: conjunto_a = set([1, 2, 3, 4, 5])
    In [18]: conjunto_b = set([4, 5, 6, 7, 8])

E assim fica mais simples a união deles.
    conjunto_a | conjunto_b
    conjunto_a.union(conjunto_b)

INTERSESSÃO DE CONJUNTOS
    In [22]: conjunto_a.intersection(conjunto_b)
    Out[22]: {4, 5}

    In [23]: conjunto_a & conjunto_b
    Out[23]: {4, 5}    

Tudo o que está em um conjunto mas não está no outro.
Algo parecido com left e right join dependendo de como especificado.
    In [24]: conjunto_a - conjunto_b
    Out[24]: {1, 2, 3}

    In [25]: conjunto_a.difference(conjunto_b)
    Out[25]: {1, 2, 3}    

DIFERENÇA SIMÉTRICA
Mostra os valores únicos do conjunto_a e os valores que só tem no conjunto_b
In [29]: conjunto_a.symmetric_difference(conjunto_b)
Out[29]: {1, 2, 3, 6, 7, 8}

In [30]: conjunto_a ^ conjunto_b
Out[30]: {1, 2, 3, 6, 7, 8}

Os sets são objetos de transição, para que no futuro 
consigamos fazer as operações de maneira mais fácil.

Adicionando valores ao set
    In [31]: conjunto_a.add(10)

    In [32]: conjunto_a
    Out[32]: {1, 2, 3, 4, 5, 10}

# Hash Table
Buscar coisas dentro de um set é muito mais rápido que em uma lista pois é 
implementado Hash Table no set. 

Nós vimos as seguintes sequencias: tuple, list, set, str
RESUMO: 
    minha_lista = [1, 2, 3, 4, 5]
    minha_tupla = (1, 2, 3, 4, 5)
    meu_set = {1, 2, 3, 4, 5, 3} ou meu_set = set((1, 2, 3, 4, 5, 3))

DICIONÁRIO
O dicionário tem características parecidas com a lista o set.
Ele é mutável, pode ser iterado, tem a hash table para ter buscas rápidas.
Ao invés de qualquer apenas um valor por posição, ele guarda dois valores:
key -> value em cada posição: cod -> 1, nome -> Bruno.

Criando um dicionário
    In [24]: cliente = {"nome": "Bruno", "cod": 123}

    Usa-se a chave para acessar valores em um dicionário.
    In [25]: cliente["nome"]
    Out[25]: 'Bruno'

    In [26]: cliente["cod"]
    Out[26]: 123

    In [36]: cliente["cidade"] = "Viana"

    Adicionando mais uma chave:valor ao cliente
    In [36]: cliente["cidade"] = "Viana"
    In [37]: cliente
    Out[37]: {'nome': 'Bruno', 'cod': 123, 'cidade': 'Viana'}
    
    Poderia também fazer assim:
    In [56]: cliente.update({"idade": 36})
    In [57]: cliente
    Out[57]: {'nome': 'Bruno', 'cod': 123, 'pais': 'Portugal', 'idade': 36}

    Atualizar um valor no dicionário
    cliente["cidade"] = "Santo André"

    Removendo um valor do dicionário através da chave.
    In [38]: del cliente["nome"]

    In [39]: cliente
    Out[39]: {'cod': 123, 'cidade': 'Viana'}

    Buscar no dicionário via chave é muito rápido por causa do hash table.
    In [43]: "cod" in cliente
    Out[43]: True

    In [44]: "nome" in cliente
    Out[44]: True

    Buscando as chaves
    In [46]: cliente.keys()
    Out[46]: dict_keys(['nome', 'cod'])

    Buscando os valores
    In [47]: cliente.values()
    Out[47]: dict_values(['Bruno', 123])

    Retorna chave e valor no formato de dupla.
    In [50]: cliente.items()
    Out[50]: dict_items([('nome', 'Bruno'), ('cod', 123)])

    Atualizando um dicionário com base em outro.
    In [52]: extra = {"pais": "Portugal"}

    In [53]: cliente.update(extra)

    In [54]: cliente
    Out[54]: {'nome': 'Bruno', 'cod': 123, 'pais': 'Portugal'}

    Desempacotamento no dicionário, para o Desempacotamento no dicionário
    precisa ser passado dois *.
    extra_cliente = {**extra, **cliente}

    Já havíamos utilizado o desempacotamento em listas.
    atividade = ['ingles', 'musica', 'danca', 'musculacao']
    head, *body, tail = atividade
    O body tem só um * porque funciona para sequencias que tenha um único
    elemento em cada posição. 
    O dicionário contém dois elementos por posição, por isso o uso de **

Para iterar em um dicionário:
Pegando somente a chave (que é mais rápido pois tem o hash)
cliente = {'nome': 'Bruno', 'cod': 123, 'pais': 'Portugal'}

    In [88]: for chave in cliente:
        ...:     print(chave)
        ...:
    nome
    cod
    pais  
Pegando chave e o valor 
In [89]: for chave in cliente:
    ...:     print(chave, "->", cliente[chave])
    ...:
nome -> Bruno
cod -> 123
pais -> Portugal

Outra forma de fazer é pegando o .items pois ele retornará uma tupla.
    In [111]: for chave, valor in cliente.items():
        ...:     print(chave, '->', valor)
        ...:
    nome -> Bruno
    cod -> 123
    pais -> Portugal

Mais um exemplo, também usando o desacoplamento.
    In [114]: nome, cod, pais = cliente.items()

    In [115]: nome
    Out[115]: ('nome', 'Bruno')

    In [116]: cod
    Out[116]: ('cod', 123)

    In [117]: pais
    Out[117]: ('pais', 'Portugal')
